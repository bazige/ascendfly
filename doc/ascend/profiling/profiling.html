<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ascend.profiling.profiling API documentation</title>
<meta name="description" content="Copyright 2020 Huawei Technologies Co., Ltd
Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
you may not use this file except in â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<link rel="preconnect" href="https://www.google.com">
<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>
.gsc-control-cse {padding:0 !important;margin-top:1em}
body.gsc-overflow-hidden #sidebar {overflow: visible;}
</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://pdoc3.github.io/pdoc/doc/ascend/profiling/profiling.html">
<link rel="icon" href="https://gitee.com/ascend-fae/ascendfly/blob/master/doc/logo/logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ascend.profiling.profiling</code></h1>
</header>
<section id="section-intro">
<p>Copyright 2020 Huawei Technologies Co., Ltd
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c0c4662b8bfdd479b00c923799cfbd69bbea0eb8/ascend/profiling/profiling.py#L0-L248" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Copyright 2020 Huawei Technologies Co., Ltd
Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
&#34;&#34;&#34;

import acl
import os
import time
import numpy as np

from ..common.const import *
from functools import wraps
from prettytable import PrettyTable
from ..resource.context import bind_context

class Profiling():
    &#34;&#34;&#34;Define a Profiling class to do profiling and finetune model.
       It define a decorator running in model infer

    Attributes:
        context (int): Context resource
        model_id (int): The model_id that profiling will do.

    Methods:
        - profiling(func): do model profiling.
        - elapse_time(func): do function timling
        - info_print(sort=False): log infomation of profiling.

    Typical usage example:
    ```python
    prof = ascend.Profiling(ctx, model.model_id)

    @prof.elapse_time
    @prof.profiling
    def run():
        model.run()

    run()
    ```
    &#34;&#34;&#34;
    def __init__(self, context, model_id, mode=1):
        if not isinstance(context, int):
            raise TypeError(f&#34;Profiling input context expects an int type, bug got {type(context)}.&#34;)
        
        if not isinstance(model_id, int):
            raise TypeError(f&#34;Profiling input model_id expects an int type, bug got {type(model_id)}.&#34;)

        bind_context(context)

        # create a pipe for communication
        self.r, self.w = os.pipe()
        self._model_id = model_id
        self._thread_id = None
        self._context = context
        self._mode = mode

        # profling data and info
        self.info = []

    def __enter__(self):
        &#34;&#34;&#34;create a subcribe config, and subscribe a thread.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        self._subs_conf = acl.prof.create_subscribe_config(1, self._mode , self.w)
        ret = acl.prof.model_subscribe(self._model_id, self._subs_conf)
        if ret != ACL_SUCCESS:
            raise ValueError(f&#34;configurate model_subscribe failed, return {ret}.&#34;)


    def _get_model_info(self, data, data_len):
        &#34;&#34;&#34; parser profiling data from memory and save to self.info

        Args:
            data    : the operators&#39; information data
            data_len: the operators&#39; information data size

        Returns:
            None
        &#34;&#34;&#34;
        op_number, ret = acl.prof.get_op_num(data, data_len)
        if ret != ACL_SUCCESS:
            raise ValueError(f&#34;get op num failed, return {ret}.&#34;)

        for i in range(op_number):
            # get model id that operator running
            model_id = acl.prof.get_model_id(data, data_len, i)

            # get type of i-th op
            op_type, ret = acl.prof.get_op_type(data, data_len, i, 65)
            assert ret == ACL_SUCCESS, f&#34;get op type failed, return {ret}.&#34;

            # get name of i-th op
            op_name, ret = acl.prof.get_op_name(data, data_len, i, 275)
            assert ret == ACL_SUCCESS, f&#34;get op type failed, return {ret}.&#34;

            # get running start time of i-th op
            op_start = acl.prof.get_op_start(data, data_len, i)

            # get running end time of i-th op
            op_end = acl.prof.get_op_end(data, data_len, i)

            # get runnning duration of i-th op
            op_duration = acl.prof.get_op_duration(data, data_len, i)

            # save profiling result
            self.info.append([model_id, op_name, op_type, op_start, op_end, op_duration])

    def info_print(self, sort=False):
        &#34;&#34;&#34;Print profiling info to terminal

        Args:
            sort (bool, optional): Whether sort the profiling result or not. Defaults to False.

        Typical usage example:
        ```python
        prof.info_print(sort=True)
        ```     
        &#34;&#34;&#34;
        items = [&#39;id&#39;, &#39;op_name&#39;, &#39;op_type&#39;, &#39;time_start&#39;, &#39;time_end&#39;, &#39;time_elapse&#39;]
        table = PrettyTable(items)

        for item in self.info:
            table.add_row(item)
        
        percent = np.array([e[-1] for e in self.info])
        percent = np.around(100 * percent / percent.sum(), decimals=2)
        table.add_column(&#39;percent(%)&#39;, percent)
        
        print(table.get_string(sortby=&#39;time_elapse&#39; if sort else None, reversesort=True))

    def _read_data(self, args):
        &#34;&#34;&#34; read profiling data to pipe and save on memory.

        Args:
            args : function input parameter
 
        Returns:
            None
        &#34;&#34;&#34;
        fd, ctx = args

        # bind context resource
        bind_context(ctx)
        
        buffer_size, ret = acl.prof.get_op_desc_size()
        if ret != ACL_SUCCESS:
            raise ValueError(f&#34;get op desc of size failed, return {ret}.&#34;)

        # caculate memory size for save op info
        data_len = buffer_size * 10

        # read profiling data from pipe, the data size maybe lower than buffer_size*N
        while True:
            data = os.read(fd, data_len)
            if len(data) == 0:
                break

            # malloc numpy data memory to save profiling data
            np_data = np.array(data)
            np_data_ptr = acl.util.numpy_to_ptr(np_data)

            # parser profiling data 
            size = np_data.itemsize * np_data.size
            self._get_model_info(np_data_ptr, size)

    def profiling(self, func):
        &#34;&#34;&#34;Start profiling thread and do profiling.

        Args:
            func (obj): the function to do profiling

        Returns:
            wrapped_function
        &#34;&#34;&#34;
        @wraps(func)
        def wrapped_function(*args, **kwargs):
            print(func.__name__ + &#34; was called, and start profiling.&#34;)

            # start profiling
            with self:
                self._thread_id, ret = acl.util.start_thread(self._read_data, [self.r, self._context])
                if ret != ACL_SUCCESS:
                    raise ValueError(f&#34;start tread {self._thread_id} failed, return {ret}.&#34;)
                
                return func(*args, **kwargs)

        return wrapped_function

    def elapse_time(self, func):
        &#34;&#34;&#34;Print function excute time.

        Args:
            func (obj): The runing function.

        Returns:
            wrapped_function
        &#34;&#34;&#34;        
        @wraps(func)
        def wrapped_function(*args, **kwargs):
            print(func.__name__ + &#34; was called, and start time.&#34;)
            
            start_time = time.time()
            res = func(*args, **kwargs)
            use_time = time.time() - start_time

            print(f&#34;{func.__name__} elapse time:{use_time}&#34;)
            return res
        return wrapped_function


    def __exit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34; unsubscribe thread and destroy subscribe config.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        if hasattr(self, &#39;_model_id&#39;):
            ret = acl.prof.model_un_subscribe(self._model_id)
            assert ret == ACL_SUCCESS, f&#34;unsubscribe profiling thread failed, return {ret}.&#34;

        if hasattr(self, &#39;_thread_id&#39;):
            ret = acl.util.stop_thread(self._thread_id)
            assert ret == ACL_SUCCESS, f&#34;stop thread {self._thread_id} failed, return {ret}.&#34;

        # close pipe
        os.close(self.r)

        ret = acl.prof.destroy_subscribe_config(self._subs_conf)
        if ret != ACL_SUCCESS:
            raise ValueError(f&#34;destroy subscribe config of profiling failed, return {ret}.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ascend.profiling.profiling.Profiling"><code class="flex name class">
<span>class <span class="ident">Profiling</span></span>
<span>(</span><span>context, model_id, mode=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Define a Profiling class to do profiling and finetune model.
It define a decorator running in model infer</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code>int</code></dt>
<dd>Context resource</dd>
<dt><strong><code>model_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The model_id that profiling will do.</dd>
</dl>
<h2 id="methods">Methods</h2>
<ul>
<li>profiling(func): do model profiling.</li>
<li>elapse_time(func): do function timling</li>
<li>info_print(sort=False): log infomation of profiling.</li>
</ul>
<p>Typical usage example:</p>
<pre><code class="language-python">prof = ascend.Profiling(ctx, model.model_id)

@prof.elapse_time
@prof.profiling
def run():
    model.run()

run()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c0c4662b8bfdd479b00c923799cfbd69bbea0eb8/ascend/profiling/profiling.py#L26-L248" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Profiling():
    &#34;&#34;&#34;Define a Profiling class to do profiling and finetune model.
       It define a decorator running in model infer

    Attributes:
        context (int): Context resource
        model_id (int): The model_id that profiling will do.

    Methods:
        - profiling(func): do model profiling.
        - elapse_time(func): do function timling
        - info_print(sort=False): log infomation of profiling.

    Typical usage example:
    ```python
    prof = ascend.Profiling(ctx, model.model_id)

    @prof.elapse_time
    @prof.profiling
    def run():
        model.run()

    run()
    ```
    &#34;&#34;&#34;
    def __init__(self, context, model_id, mode=1):
        if not isinstance(context, int):
            raise TypeError(f&#34;Profiling input context expects an int type, bug got {type(context)}.&#34;)
        
        if not isinstance(model_id, int):
            raise TypeError(f&#34;Profiling input model_id expects an int type, bug got {type(model_id)}.&#34;)

        bind_context(context)

        # create a pipe for communication
        self.r, self.w = os.pipe()
        self._model_id = model_id
        self._thread_id = None
        self._context = context
        self._mode = mode

        # profling data and info
        self.info = []

    def __enter__(self):
        &#34;&#34;&#34;create a subcribe config, and subscribe a thread.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        self._subs_conf = acl.prof.create_subscribe_config(1, self._mode , self.w)
        ret = acl.prof.model_subscribe(self._model_id, self._subs_conf)
        if ret != ACL_SUCCESS:
            raise ValueError(f&#34;configurate model_subscribe failed, return {ret}.&#34;)


    def _get_model_info(self, data, data_len):
        &#34;&#34;&#34; parser profiling data from memory and save to self.info

        Args:
            data    : the operators&#39; information data
            data_len: the operators&#39; information data size

        Returns:
            None
        &#34;&#34;&#34;
        op_number, ret = acl.prof.get_op_num(data, data_len)
        if ret != ACL_SUCCESS:
            raise ValueError(f&#34;get op num failed, return {ret}.&#34;)

        for i in range(op_number):
            # get model id that operator running
            model_id = acl.prof.get_model_id(data, data_len, i)

            # get type of i-th op
            op_type, ret = acl.prof.get_op_type(data, data_len, i, 65)
            assert ret == ACL_SUCCESS, f&#34;get op type failed, return {ret}.&#34;

            # get name of i-th op
            op_name, ret = acl.prof.get_op_name(data, data_len, i, 275)
            assert ret == ACL_SUCCESS, f&#34;get op type failed, return {ret}.&#34;

            # get running start time of i-th op
            op_start = acl.prof.get_op_start(data, data_len, i)

            # get running end time of i-th op
            op_end = acl.prof.get_op_end(data, data_len, i)

            # get runnning duration of i-th op
            op_duration = acl.prof.get_op_duration(data, data_len, i)

            # save profiling result
            self.info.append([model_id, op_name, op_type, op_start, op_end, op_duration])

    def info_print(self, sort=False):
        &#34;&#34;&#34;Print profiling info to terminal

        Args:
            sort (bool, optional): Whether sort the profiling result or not. Defaults to False.

        Typical usage example:
        ```python
        prof.info_print(sort=True)
        ```     
        &#34;&#34;&#34;
        items = [&#39;id&#39;, &#39;op_name&#39;, &#39;op_type&#39;, &#39;time_start&#39;, &#39;time_end&#39;, &#39;time_elapse&#39;]
        table = PrettyTable(items)

        for item in self.info:
            table.add_row(item)
        
        percent = np.array([e[-1] for e in self.info])
        percent = np.around(100 * percent / percent.sum(), decimals=2)
        table.add_column(&#39;percent(%)&#39;, percent)
        
        print(table.get_string(sortby=&#39;time_elapse&#39; if sort else None, reversesort=True))

    def _read_data(self, args):
        &#34;&#34;&#34; read profiling data to pipe and save on memory.

        Args:
            args : function input parameter
 
        Returns:
            None
        &#34;&#34;&#34;
        fd, ctx = args

        # bind context resource
        bind_context(ctx)
        
        buffer_size, ret = acl.prof.get_op_desc_size()
        if ret != ACL_SUCCESS:
            raise ValueError(f&#34;get op desc of size failed, return {ret}.&#34;)

        # caculate memory size for save op info
        data_len = buffer_size * 10

        # read profiling data from pipe, the data size maybe lower than buffer_size*N
        while True:
            data = os.read(fd, data_len)
            if len(data) == 0:
                break

            # malloc numpy data memory to save profiling data
            np_data = np.array(data)
            np_data_ptr = acl.util.numpy_to_ptr(np_data)

            # parser profiling data 
            size = np_data.itemsize * np_data.size
            self._get_model_info(np_data_ptr, size)

    def profiling(self, func):
        &#34;&#34;&#34;Start profiling thread and do profiling.

        Args:
            func (obj): the function to do profiling

        Returns:
            wrapped_function
        &#34;&#34;&#34;
        @wraps(func)
        def wrapped_function(*args, **kwargs):
            print(func.__name__ + &#34; was called, and start profiling.&#34;)

            # start profiling
            with self:
                self._thread_id, ret = acl.util.start_thread(self._read_data, [self.r, self._context])
                if ret != ACL_SUCCESS:
                    raise ValueError(f&#34;start tread {self._thread_id} failed, return {ret}.&#34;)
                
                return func(*args, **kwargs)

        return wrapped_function

    def elapse_time(self, func):
        &#34;&#34;&#34;Print function excute time.

        Args:
            func (obj): The runing function.

        Returns:
            wrapped_function
        &#34;&#34;&#34;        
        @wraps(func)
        def wrapped_function(*args, **kwargs):
            print(func.__name__ + &#34; was called, and start time.&#34;)
            
            start_time = time.time()
            res = func(*args, **kwargs)
            use_time = time.time() - start_time

            print(f&#34;{func.__name__} elapse time:{use_time}&#34;)
            return res
        return wrapped_function


    def __exit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34; unsubscribe thread and destroy subscribe config.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        if hasattr(self, &#39;_model_id&#39;):
            ret = acl.prof.model_un_subscribe(self._model_id)
            assert ret == ACL_SUCCESS, f&#34;unsubscribe profiling thread failed, return {ret}.&#34;

        if hasattr(self, &#39;_thread_id&#39;):
            ret = acl.util.stop_thread(self._thread_id)
            assert ret == ACL_SUCCESS, f&#34;stop thread {self._thread_id} failed, return {ret}.&#34;

        # close pipe
        os.close(self.r)

        ret = acl.prof.destroy_subscribe_config(self._subs_conf)
        if ret != ACL_SUCCESS:
            raise ValueError(f&#34;destroy subscribe config of profiling failed, return {ret}.&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ascend.profiling.profiling.Profiling.elapse_time"><code class="name flex">
<span>def <span class="ident">elapse_time</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<div class="desc"><p>Print function excute time.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>obj</code></dt>
<dd>The runing function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>wrapped_function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c0c4662b8bfdd479b00c923799cfbd69bbea0eb8/ascend/profiling/profiling.py#L204-L223" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def elapse_time(self, func):
    &#34;&#34;&#34;Print function excute time.

    Args:
        func (obj): The runing function.

    Returns:
        wrapped_function
    &#34;&#34;&#34;        
    @wraps(func)
    def wrapped_function(*args, **kwargs):
        print(func.__name__ + &#34; was called, and start time.&#34;)
        
        start_time = time.time()
        res = func(*args, **kwargs)
        use_time = time.time() - start_time

        print(f&#34;{func.__name__} elapse time:{use_time}&#34;)
        return res
    return wrapped_function</code></pre>
</details>
</dd>
<dt id="ascend.profiling.profiling.Profiling.info_print"><code class="name flex">
<span>def <span class="ident">info_print</span></span>(<span>self, sort=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Print profiling info to terminal</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sort</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether sort the profiling result or not. Defaults to False.</dd>
</dl>
<p>Typical usage example:</p>
<pre><code class="language-python">prof.info_print(sort=True)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c0c4662b8bfdd479b00c923799cfbd69bbea0eb8/ascend/profiling/profiling.py#L123-L144" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def info_print(self, sort=False):
    &#34;&#34;&#34;Print profiling info to terminal

    Args:
        sort (bool, optional): Whether sort the profiling result or not. Defaults to False.

    Typical usage example:
    ```python
    prof.info_print(sort=True)
    ```     
    &#34;&#34;&#34;
    items = [&#39;id&#39;, &#39;op_name&#39;, &#39;op_type&#39;, &#39;time_start&#39;, &#39;time_end&#39;, &#39;time_elapse&#39;]
    table = PrettyTable(items)

    for item in self.info:
        table.add_row(item)
    
    percent = np.array([e[-1] for e in self.info])
    percent = np.around(100 * percent / percent.sum(), decimals=2)
    table.add_column(&#39;percent(%)&#39;, percent)
    
    print(table.get_string(sortby=&#39;time_elapse&#39; if sort else None, reversesort=True))</code></pre>
</details>
</dd>
<dt id="ascend.profiling.profiling.Profiling.profiling"><code class="name flex">
<span>def <span class="ident">profiling</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<div class="desc"><p>Start profiling thread and do profiling.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>obj</code></dt>
<dd>the function to do profiling</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>wrapped_function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c0c4662b8bfdd479b00c923799cfbd69bbea0eb8/ascend/profiling/profiling.py#L181-L202" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def profiling(self, func):
    &#34;&#34;&#34;Start profiling thread and do profiling.

    Args:
        func (obj): the function to do profiling

    Returns:
        wrapped_function
    &#34;&#34;&#34;
    @wraps(func)
    def wrapped_function(*args, **kwargs):
        print(func.__name__ + &#34; was called, and start profiling.&#34;)

        # start profiling
        with self:
            self._thread_id, ret = acl.util.start_thread(self._read_data, [self.r, self._context])
            if ret != ACL_SUCCESS:
                raise ValueError(f&#34;start tread {self._thread_id} failed, return {ret}.&#34;)
            
            return func(*args, **kwargs)

    return wrapped_function</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="ascendfly Home" href="https://gitee.com/ascend-fae/ascendfly">
<img src="https://gitee.com/ascend-fae/ascendfly/blob/master/doc/logo/logo.png" alt=""> ascendfly
</a>
</header>
<div class="gcse-search" style="height: 70px"
data-as_oq="site:pdoc3.github.io inurl:github.com/pdoc3"
data-gaCategoryParameter="ascend.profiling.profiling">
</div>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ascend.profiling" href="index.html">ascend.profiling</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ascend.profiling.profiling.Profiling" href="#ascend.profiling.profiling.Profiling">Profiling</a></code></h4>
<ul class="">
<li><code><a title="ascend.profiling.profiling.Profiling.elapse_time" href="#ascend.profiling.profiling.Profiling.elapse_time">elapse_time</a></code></li>
<li><code><a title="ascend.profiling.profiling.Profiling.info_print" href="#ascend.profiling.profiling.Profiling.info_print">info_print</a></code></li>
<li><code><a title="ascend.profiling.profiling.Profiling.profiling" href="#ascend.profiling.profiling.Profiling.profiling">profiling</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p><span style="color:#ddd">&#21328;</span></p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ascend.data.tensor API documentation</title>
<meta name="description" content="Copyright 2020 Huawei Technologies Co., Ltd
Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
you may not use this file except in â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<link rel="preconnect" href="https://www.google.com">
<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>
.gsc-control-cse {padding:0 !important;margin-top:1em}
body.gsc-overflow-hidden #sidebar {overflow: visible;}
</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://pdoc3.github.io/pdoc/doc/ascend/data/tensor.html">
<link rel="icon" href="https://gitee.com/ascend-fae/ascendfly/blob/master/doc/logo/logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ascend.data.tensor</code></h1>
</header>
<section id="section-intro">
<p>Copyright 2020 Huawei Technologies Co., Ltd
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c0c4662b8bfdd479b00c923799cfbd69bbea0eb8/ascend/data/tensor.py#L0-L160" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Copyright 2020 Huawei Technologies Co., Ltd
Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
&#34;&#34;&#34;
import numpy as np

from ..common.const import *
from ..resource.mem import memcpy_d2d
from ..data.ascendarray import AscendArray
from ..ops.op import Permute


def _imdenormalize(img, mean, std, to_bgr=True):
    assert img.dtype != np.uint8
    mean = mean.reshape(1, -1).astype(np.float64)
    std = std.reshape(1, -1).astype(np.float64)

    # make a copy
    img = np.multiply(img, std)

    # inplace
    img = np.add(img, mean)
    if to_bgr:
        img = img[:, :, ::-1]
    return img


def imgs2tensor(imgs, tensor_fmt=&#39;NCHW&#39;, tensor_ptr=None):
    &#34;&#34;&#34;Convert 3-channel images to tensor

    Args:
        imgs (list[AscendArray]): A list that contains multiple images,
            shape (h, w, c), support RGB/BGR, YUV444
        tensor_fmt (str, optional): Data format of output tensor. Defaults to &#39;NCHW&#39;.
        tensor_ptr (int, optional): Data pointer of output tensor. If it is None, 
            we will create an AscendArray and bind the array&#39;s data pointer to it. 
            Defaults to None.

    Returns:
        AscendArray: Tensor that contains multiple images, shape (N, C, H, W) 
            or shape (N, H, W, C)

    Typical usage example:
    ```python
    imgs = [ascend_array1, ascend_array2]
    data = ascend.imgs2tensor(imgs, tensor_fmt=&#39;NHWC&#39;)
    ```
    &#34;&#34;&#34;
    if not isinstance(imgs, list):
        raise TypeError(f&#34;Input imgs expects a list, but got {type(imgs)}.&#34;)

    if len(imgs) &lt;= 0:
        raise ValueError(f&#34;Input imgs is a null list.&#34;)

    # get first image&#39;s shape and format
    format = imgs[0].format
    _shape = imgs[0].shape
    if format in yuv420:
        shape = _shape + (1,)
    else:
        shape = _shape

    # generate output tensor shape
    if tensor_fmt == &#39;NCHW&#39;:
        tensor_shape = (len(imgs),) + shape[-1:] + shape[:-1]
    elif tensor_fmt == &#39;NHWC&#39;:
        tensor_shape = (len(imgs),) + shape
    else:
        raise ValueError(
            f&#34;Tensor format only accept &#39;NCHW&#39; or &#39;NHWC&#39;, but got {tensor_fmt}.&#34;)

    if not tensor_ptr:
        tensor = AscendArray(
            tensor_shape, dtype=imgs[0].dtype, format=tensor_fmt)
        _ptr = tensor.ascend_data
    else:
        assert isinstance(tensor_ptr, int), \
            f&#34;Input tensor_ptr expects an int, but got {type(tensor_ptr)}.&#34;
        _ptr = tensor_ptr

    nbytes = 0
    for i, img in enumerate(imgs):
        assert _shape == img.shape, f&#34;imgs[{i}]&#39;s shape {img.shape} is not same to others.&#34;
        assert format == img.format, f&#34;imgs[{i}]&#39;s format {img.shape} is not same to others.&#34;

        if tensor_fmt == &#39;NCHW&#39;:
            # swap channel using transform operator
            &#39;&#39;&#39;
            to do transformer
            &#39;&#39;&#39;
            pass

        nbytes = nbytes + img.nbytes
        memcpy_d2d(_ptr + nbytes, img.ascend_data, img.nbytes)

    return tensor if not tensor_ptr else None


def tensor2imgs(tensor, mean=(0, 0, 0), std=(1, 1, 1), to_rgb=True):
    &#34;&#34;&#34;Convert tensor to a 3-channel images

    Args:
        tensor (AscendArray): Tensor that contains multiple images, shape (N, C, H, W) or shape (N, H, W, C)
        mean (tuple[float], optional): The mean value of images. Defaults to (0, 0, 0).
        std (tuple[float], optional): The standard deviation of images. Defaults to (1, 1, 1).
        to_rgb (bool, optional): Whether the tensor was converted to RGB format in the first place.
            If so, convert it back to BGR. Defaults to True.

    Returns:
        list[np.ndarray]: A list that contains multiple images.

    Typical usage example:
    ```python
    imgs = ascend.tensor2imgs(tensors)
    ```
    &#34;&#34;&#34;
    if not isinstance(tensor, AscendArray):
        raise TypeError(
            f&#34;Input tensor expects an AscendArray, but got {type(tensor)}.&#34;)

    if tensor.ndim != 4:
        raise ValueError(
            f&#34;Input tensor expects a 4-dim, but got {tensor.ndim}.&#34;)

    if tensor.format not in [&#34;NCHW&#34;, &#34;NHWC&#34;]:
        raise ValueError(
            f&#34;Input tensor&#39;s format only support &#39;NCHW&#39; or &#39;NHWC&#39;, but given {tensor.format}.&#34;)

    assert len(mean) == 3, \
        f&#34;Input mean of images expects a 3-elements tuple, but got {len(mean)}.&#34;
    assert len(std) == 3, \
        f&#34;Input std of images expects a 3-elements tuple, but got {len(std)}.&#34;

    batch_size = tensor.shape[0]
    mean = np.array(mean, dtype=np.float32)
    std = np.array(std, dtype=np.float32)

    if tensor.format == &#34;NCHW&#34;:
        try:
            tensor = Permute(tensor, axes=(0, 2, 3, 1))
        except:
            tensor = tensor.to_np.transpose(0, 2, 3, 1)
    else:
        tensor = tensor.to_np

    imgs = []
    for img_id in range(batch_size):
        img = tensor[img_id, ...]
        img = _imdenormalize(img, mean, std, to_bgr=to_rgb).astype(np.uint8)
        imgs.append(np.ascontiguousarray(img))
    return imgs</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ascend.data.tensor.imgs2tensor"><code class="name flex">
<span>def <span class="ident">imgs2tensor</span></span>(<span>imgs, tensor_fmt='NCHW', tensor_ptr=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert 3-channel images to tensor</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>imgs</code></strong> :&ensp;<code>list[AscendArray]</code></dt>
<dd>A list that contains multiple images,
shape (h, w, c), support RGB/BGR, YUV444</dd>
<dt><strong><code>tensor_fmt</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Data format of output tensor. Defaults to 'NCHW'.</dd>
<dt><strong><code>tensor_ptr</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Data pointer of output tensor. If it is None,
we will create an AscendArray and bind the array's data pointer to it.
Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>AscendArray</code></dt>
<dd>Tensor that contains multiple images, shape (N, C, H, W)
or shape (N, H, W, C)</dd>
</dl>
<p>Typical usage example:</p>
<pre><code class="language-python">imgs = [ascend_array1, ascend_array2]
data = ascend.imgs2tensor(imgs, tensor_fmt='NHWC')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c0c4662b8bfdd479b00c923799cfbd69bbea0eb8/ascend/data/tensor.py#L38-L106" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imgs2tensor(imgs, tensor_fmt=&#39;NCHW&#39;, tensor_ptr=None):
    &#34;&#34;&#34;Convert 3-channel images to tensor

    Args:
        imgs (list[AscendArray]): A list that contains multiple images,
            shape (h, w, c), support RGB/BGR, YUV444
        tensor_fmt (str, optional): Data format of output tensor. Defaults to &#39;NCHW&#39;.
        tensor_ptr (int, optional): Data pointer of output tensor. If it is None, 
            we will create an AscendArray and bind the array&#39;s data pointer to it. 
            Defaults to None.

    Returns:
        AscendArray: Tensor that contains multiple images, shape (N, C, H, W) 
            or shape (N, H, W, C)

    Typical usage example:
    ```python
    imgs = [ascend_array1, ascend_array2]
    data = ascend.imgs2tensor(imgs, tensor_fmt=&#39;NHWC&#39;)
    ```
    &#34;&#34;&#34;
    if not isinstance(imgs, list):
        raise TypeError(f&#34;Input imgs expects a list, but got {type(imgs)}.&#34;)

    if len(imgs) &lt;= 0:
        raise ValueError(f&#34;Input imgs is a null list.&#34;)

    # get first image&#39;s shape and format
    format = imgs[0].format
    _shape = imgs[0].shape
    if format in yuv420:
        shape = _shape + (1,)
    else:
        shape = _shape

    # generate output tensor shape
    if tensor_fmt == &#39;NCHW&#39;:
        tensor_shape = (len(imgs),) + shape[-1:] + shape[:-1]
    elif tensor_fmt == &#39;NHWC&#39;:
        tensor_shape = (len(imgs),) + shape
    else:
        raise ValueError(
            f&#34;Tensor format only accept &#39;NCHW&#39; or &#39;NHWC&#39;, but got {tensor_fmt}.&#34;)

    if not tensor_ptr:
        tensor = AscendArray(
            tensor_shape, dtype=imgs[0].dtype, format=tensor_fmt)
        _ptr = tensor.ascend_data
    else:
        assert isinstance(tensor_ptr, int), \
            f&#34;Input tensor_ptr expects an int, but got {type(tensor_ptr)}.&#34;
        _ptr = tensor_ptr

    nbytes = 0
    for i, img in enumerate(imgs):
        assert _shape == img.shape, f&#34;imgs[{i}]&#39;s shape {img.shape} is not same to others.&#34;
        assert format == img.format, f&#34;imgs[{i}]&#39;s format {img.shape} is not same to others.&#34;

        if tensor_fmt == &#39;NCHW&#39;:
            # swap channel using transform operator
            &#39;&#39;&#39;
            to do transformer
            &#39;&#39;&#39;
            pass

        nbytes = nbytes + img.nbytes
        memcpy_d2d(_ptr + nbytes, img.ascend_data, img.nbytes)

    return tensor if not tensor_ptr else None</code></pre>
</details>
</dd>
<dt id="ascend.data.tensor.tensor2imgs"><code class="name flex">
<span>def <span class="ident">tensor2imgs</span></span>(<span>tensor, mean=(0, 0, 0), std=(1, 1, 1), to_rgb=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert tensor to a 3-channel images</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tensor</code></strong> :&ensp;<code>AscendArray</code></dt>
<dd>Tensor that contains multiple images, shape (N, C, H, W) or shape (N, H, W, C)</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>tuple[float]</code>, optional</dt>
<dd>The mean value of images. Defaults to (0, 0, 0).</dd>
<dt><strong><code>std</code></strong> :&ensp;<code>tuple[float]</code>, optional</dt>
<dd>The standard deviation of images. Defaults to (1, 1, 1).</dd>
<dt><strong><code>to_rgb</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether the tensor was converted to RGB format in the first place.
If so, convert it back to BGR. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[np.ndarray]</code></dt>
<dd>A list that contains multiple images.</dd>
</dl>
<p>Typical usage example:</p>
<pre><code class="language-python">imgs = ascend.tensor2imgs(tensors)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdoc3/pdoc/blob/c0c4662b8bfdd479b00c923799cfbd69bbea0eb8/ascend/data/tensor.py#L109-L161" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tensor2imgs(tensor, mean=(0, 0, 0), std=(1, 1, 1), to_rgb=True):
    &#34;&#34;&#34;Convert tensor to a 3-channel images

    Args:
        tensor (AscendArray): Tensor that contains multiple images, shape (N, C, H, W) or shape (N, H, W, C)
        mean (tuple[float], optional): The mean value of images. Defaults to (0, 0, 0).
        std (tuple[float], optional): The standard deviation of images. Defaults to (1, 1, 1).
        to_rgb (bool, optional): Whether the tensor was converted to RGB format in the first place.
            If so, convert it back to BGR. Defaults to True.

    Returns:
        list[np.ndarray]: A list that contains multiple images.

    Typical usage example:
    ```python
    imgs = ascend.tensor2imgs(tensors)
    ```
    &#34;&#34;&#34;
    if not isinstance(tensor, AscendArray):
        raise TypeError(
            f&#34;Input tensor expects an AscendArray, but got {type(tensor)}.&#34;)

    if tensor.ndim != 4:
        raise ValueError(
            f&#34;Input tensor expects a 4-dim, but got {tensor.ndim}.&#34;)

    if tensor.format not in [&#34;NCHW&#34;, &#34;NHWC&#34;]:
        raise ValueError(
            f&#34;Input tensor&#39;s format only support &#39;NCHW&#39; or &#39;NHWC&#39;, but given {tensor.format}.&#34;)

    assert len(mean) == 3, \
        f&#34;Input mean of images expects a 3-elements tuple, but got {len(mean)}.&#34;
    assert len(std) == 3, \
        f&#34;Input std of images expects a 3-elements tuple, but got {len(std)}.&#34;

    batch_size = tensor.shape[0]
    mean = np.array(mean, dtype=np.float32)
    std = np.array(std, dtype=np.float32)

    if tensor.format == &#34;NCHW&#34;:
        try:
            tensor = Permute(tensor, axes=(0, 2, 3, 1))
        except:
            tensor = tensor.to_np.transpose(0, 2, 3, 1)
    else:
        tensor = tensor.to_np

    imgs = []
    for img_id in range(batch_size):
        img = tensor[img_id, ...]
        img = _imdenormalize(img, mean, std, to_bgr=to_rgb).astype(np.uint8)
        imgs.append(np.ascontiguousarray(img))
    return imgs</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="ascendfly Home" href="https://gitee.com/ascend-fae/ascendfly">
<img src="https://gitee.com/ascend-fae/ascendfly/blob/master/doc/logo/logo.png" alt=""> ascendfly
</a>
</header>
<div class="gcse-search" style="height: 70px"
data-as_oq="site:pdoc3.github.io inurl:github.com/pdoc3"
data-gaCategoryParameter="ascend.data.tensor">
</div>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ascend.data" href="index.html">ascend.data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ascend.data.tensor.imgs2tensor" href="#ascend.data.tensor.imgs2tensor">imgs2tensor</a></code></li>
<li><code><a title="ascend.data.tensor.tensor2imgs" href="#ascend.data.tensor.tensor2imgs">tensor2imgs</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p><span style="color:#ddd">&#21328;</span></p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>